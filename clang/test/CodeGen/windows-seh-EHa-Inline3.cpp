// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 6
// RUN: %clang_cc1 -O3 -triple x86_64-windows -fasync-exceptions -fcxx-exceptions -fexceptions -fms-extensions -x c++ -Wno-implicit-function-declaration -emit-llvm %s -o - | FileCheck %s
// Check that the outermost __try scope containing a return statement is terminated upon inlining into main.
int AlwaysThrows(int);
[[noreturn]] void Exit();
volatile int *p{nullptr};

int ExitOnThrow(int argc) noexcept
{
  __try {
    __try {
      if (!argc) { *p = 0; }
      return argc;
    } __except(1) {}
  } __except(1) {}

  Exit();
  return 0;
}

// CHECK-LABEL: define dso_local noundef i32 @main(
// CHECK-SAME: i32 noundef [[ARGC:%.*]], ptr noundef readnone captures(none) [[TMP0:%.*]]) local_unnamed_addr #[[ATTR4:[0-9]+]] personality ptr @__C_specific_handler {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[ARGC_ADDR_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[__EXCEPTION_CODE1_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[CLEANUP_DEST_SLOT_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[ARGC_ADDR_I]])
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[__EXCEPTION_CODE1_I]])
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[CLEANUP_DEST_SLOT_I]])
// CHECK-NEXT:    store i32 [[ARGC]], ptr [[ARGC_ADDR_I]], align 4, !tbaa [[INT_TBAA7:![0-9]+]]
// CHECK-NEXT:    invoke void @llvm.seh.try.begin()
// CHECK-NEXT:            to label %[[INVOKE_CONT_I:.*]] unwind label %[[CATCH_DISPATCH5_I:.*]]
// CHECK:       [[INVOKE_CONT_I]]:
// CHECK-NEXT:    invoke void @llvm.seh.try.begin()
// CHECK-NEXT:            to label %[[INVOKE_CONT2_I:.*]] unwind label %[[CATCH_DISPATCH_I:.*]]
// CHECK:       [[CATCH_DISPATCH_I]]:
// CHECK-NEXT:    [[TMP1:%.*]] = catchswitch within none [label %[[__EXCEPT_I:.*]]] unwind label %[[CATCH_DISPATCH5_I]]
// CHECK:       [[__EXCEPT_I]]:
// CHECK-NEXT:    [[TMP2:%.*]] = catchpad within [[TMP1]] [ptr null]
// CHECK-NEXT:    catchret from [[TMP2]] to label %[[__EXCEPT3_I:.*]]
// CHECK:       [[__EXCEPT3_I]]:
// CHECK-NEXT:    [[TMP3:%.*]] = tail call i32 @llvm.eh.exceptioncode(token [[TMP2]])
// CHECK-NEXT:    store volatile i32 [[TMP3]], ptr [[__EXCEPTION_CODE1_I]], align 4
// CHECK-NEXT:    invoke void @llvm.seh.try.end()
// CHECK-NEXT:            to label %[[__TRY_CONT8_I:.*]] unwind label %[[CATCH_DISPATCH5_I]]
// CHECK:       [[CATCH_DISPATCH5_I]]:
// CHECK-NEXT:    [[TMP4:%.*]] = catchswitch within none [label %[[__EXCEPT6_I:.*]]] unwind to caller
// CHECK:       [[__EXCEPT6_I]]:
// CHECK-NEXT:    [[TMP5:%.*]] = catchpad within [[TMP4]] [ptr null]
// CHECK-NEXT:    catchret from [[TMP5]] to label %[[__EXCEPT7_I:.*]]
// CHECK:       [[__EXCEPT7_I]]:
// CHECK-NEXT:    [[TMP6:%.*]] = tail call i32 @llvm.eh.exceptioncode(token [[TMP5]])
// CHECK-NEXT:    br label %[[__TRY_CONT8_I]]
// CHECK:       [[__TRY_CONT8_I]]:
// CHECK-NEXT:    tail call void @"?Exit@@YAXXZ"() #[[ATTR7:[0-9]+]]
// CHECK-NEXT:    unreachable
// CHECK:       [[INVOKE_CONT2_I]]:
// CHECK-NEXT:    [[ARGC_ADDR_I_0_ARGC_ADDR_I_0_ARGC_ADDR_I_0_ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0__I:%.*]] = load volatile i32, ptr [[ARGC_ADDR_I]], align 4, !tbaa [[INT_TBAA7]]
// CHECK-NEXT:    [[TOBOOL_NOT_I:%.*]] = icmp eq i32 [[ARGC_ADDR_I_0_ARGC_ADDR_I_0_ARGC_ADDR_I_0_ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0__I]], 0
// CHECK-NEXT:    br i1 [[TOBOOL_NOT_I]], label %[[IF_THEN_I:.*]], label %[[IF_END_I:.*]]
// CHECK:       [[IF_THEN_I]]:
// CHECK-NEXT:    [[TMP7:%.*]] = load volatile ptr, ptr @"?p@@3PECHEC", align 8, !tbaa [[INTPTR_TBAA11:![0-9]+]]
// CHECK-NEXT:    store volatile i32 0, ptr [[TMP7]], align 4, !tbaa [[INT_TBAA7]]
// CHECK-NEXT:    br label %[[IF_END_I]]
// CHECK:       [[IF_END_I]]:
// CHECK-NEXT:    [[ARGC_ADDR_I_0_ARGC_ADDR_I_0_ARGC_ADDR_I_0_ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0_10_I:%.*]] = load volatile i32, ptr [[ARGC_ADDR_I]], align 4, !tbaa [[INT_TBAA7]]
// CHECK-NEXT:    store volatile i32 1, ptr [[CLEANUP_DEST_SLOT_I]], align 4
// CHECK-NEXT:    invoke void @llvm.seh.try.end()
// CHECK-NEXT:            to label %"?ExitOnThrow@@YAHH@Z.exit" unwind label %[[CATCH_DISPATCH5_I]]
// CHECK:       "?ExitOnThrow@@YAHH@Z.exit":
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[ARGC_ADDR_I]])
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[__EXCEPTION_CODE1_I]])
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[CLEANUP_DEST_SLOT_I]])
// CHECK-NEXT:    [[CALL1:%.*]] = tail call noundef i32 @"?AlwaysThrows@@YAHH@Z"(i32 noundef [[ARGC_ADDR_I_0_ARGC_ADDR_I_0_ARGC_ADDR_I_0_ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0_10_I]])
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[CALL1]], [[ARGC_ADDR_I_0_ARGC_ADDR_I_0_ARGC_ADDR_I_0_ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0_10_I]]
// CHECK-NEXT:    ret i32 [[ADD]]
//
int main(int argc, char**)
{
  auto data = ExitOnThrow(argc);
  return data + AlwaysThrows(data);
}
//.
// CHECK: [[INT_TBAA7]] = !{[[META8:![0-9]+]], [[META8]], i64 0}
// CHECK: [[META8]] = !{!"int", [[META9:![0-9]+]], i64 0}
// CHECK: [[META9]] = !{!"omnipotent char", [[META10:![0-9]+]], i64 0}
// CHECK: [[META10]] = !{!"Simple C++ TBAA"}
// CHECK: [[INTPTR_TBAA11]] = !{[[META12:![0-9]+]], [[META12]], i64 0}
// CHECK: [[META12]] = !{!"p1 int", [[META13:![0-9]+]], i64 0}
// CHECK: [[META13]] = !{!"any pointer", [[META9]], i64 0}
//.
