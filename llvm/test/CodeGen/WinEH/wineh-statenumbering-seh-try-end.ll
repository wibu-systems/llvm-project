; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s | FileCheck %s
target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-windows-pc"

@p = dso_local global ptr null, align 8

define dso_local noundef i32 @main(i32 noundef %argc, ptr noundef readnone captures(none) %argv) local_unnamed_addr personality ptr @__C_specific_handler {
; CHECK-LABEL: main:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    .seh_pushreg %rbp
; CHECK-NEXT:    pushq %rsi
; CHECK-NEXT:    .seh_pushreg %rsi
; CHECK-NEXT:    subq $56, %rsp
; CHECK-NEXT:    .seh_stackalloc 56
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rbp
; CHECK-NEXT:    .seh_setframe %rbp, 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:  .Ltmp0: # EH_LABEL
; CHECK-NEXT:    nop
; CHECK-NEXT:    movl %ecx, 4(%rbp)
; CHECK-NEXT:  .Ltmp1: # EH_LABEL
; CHECK-NEXT:  # %bb.1: # %invoke.cont2.i
; CHECK-NEXT:  .Ltmp6: # EH_LABEL
; CHECK-NEXT:    nop
; CHECK-NEXT:    cmpl $0, 4(%rbp)
; CHECK-NEXT:  .Ltmp7: # EH_LABEL
; CHECK-NEXT:    jne .LBB0_3
; CHECK-NEXT:  # %bb.2: # %if.then.i
; CHECK-NEXT:  .Ltmp8: # EH_LABEL
; CHECK-NEXT:    nop
; CHECK-NEXT:    movq p(%rip), %rax
; CHECK-NEXT:    movl $1, (%rax)
; CHECK-NEXT:  .Ltmp9: # EH_LABEL
; CHECK-NEXT:  .LBB0_3: # %if.end.i
; CHECK-NEXT:  .Ltmp10: # EH_LABEL
; CHECK-NEXT:    nop
; CHECK-NEXT:    movl 4(%rbp), %esi
; CHECK-NEXT:    movl $1, (%rbp)
; CHECK-NEXT:  .Ltmp11: # EH_LABEL
; CHECK-NEXT:  # %bb.4: # %"?ExitOnThrow@@YAHH@Z.exit"
; CHECK-NEXT:  .Ltmp12: # EH_LABEL
; CHECK-NEXT:    leal 5(%rsi), %ecx
; CHECK-NEXT:    callq "?AlwaysThrows@@YAHH@Z"
; CHECK-NEXT:    # kill: def $eax killed $eax def $rax
; CHECK-NEXT:    leal 5(%rax,%rsi), %eax
; CHECK-NEXT:  .Ltmp13: # EH_LABEL
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    addq $56, %rsp
; CHECK-NEXT:    popq %rsi
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    retq
; CHECK-NEXT:  .LBB0_5: # %__except.i
; CHECK-NEXT:  $ehgcr_0_5:
; CHECK-NEXT:  .Ltmp2: # EH_LABEL
; CHECK-NEXT:    nop
; CHECK-NEXT:    movl %eax, -4(%rbp)
; CHECK-NEXT:  .Ltmp3: # EH_LABEL
; CHECK-NEXT:    jmp .LBB0_7
; CHECK-NEXT:  .LBB0_6: # %__except6.i
; CHECK-NEXT:  $ehgcr_0_6:
; CHECK-NEXT:  .LBB0_7: # %__try.cont8.i
; CHECK-NEXT:  .Ltmp4: # EH_LABEL
; CHECK-NEXT:    callq Exit
; CHECK-NEXT:    int3
; CHECK-NEXT:  .Ltmp5: # EH_LABEL
; CHECK-NEXT:  .Lfunc_end0:
; CHECK-NEXT:    .seh_handlerdata
; CHECK-NEXT:  .Lmain$parent_frame_offset = 48
; CHECK-NEXT:    .long (.Llsda_end0-.Llsda_begin0)/16 # Number of call sites
; CHECK-NEXT:  .Llsda_begin0:
; CHECK-NEXT:    .long .Ltmp6@IMGREL # LabelStart
; CHECK-NEXT:    .long .Ltmp11@IMGREL # LabelEnd
; CHECK-NEXT:    .long 1 # CatchAll
; CHECK-NEXT:    .long .LBB0_5@IMGREL # ExceptionHandler
; CHECK-NEXT:    .long .Ltmp6@IMGREL # LabelStart
; CHECK-NEXT:    .long .Ltmp11@IMGREL # LabelEnd
; CHECK-NEXT:    .long 1 # CatchAll
; CHECK-NEXT:    .long .LBB0_6@IMGREL # ExceptionHandler
; CHECK-NEXT:    .long .Ltmp2@IMGREL # LabelStart
; CHECK-NEXT:    .long .Ltmp3@IMGREL # LabelEnd
; CHECK-NEXT:    .long 1 # CatchAll
; CHECK-NEXT:    .long .LBB0_6@IMGREL # ExceptionHandler
; CHECK-NEXT:  .Llsda_end0:
; CHECK-NEXT:    .text
; CHECK-NEXT:    .seh_endproc
entry:
  %argc.addr.i = alloca i32, align 4
  %__exception_code1.i = alloca i32, align 4
  %cleanup.dest.slot.i = alloca i32, align 4
  call void @llvm.lifetime.start.p0(ptr nonnull %argc.addr.i)
  call void @llvm.lifetime.start.p0(ptr nonnull %__exception_code1.i)
  call void @llvm.lifetime.start.p0(ptr nonnull %cleanup.dest.slot.i)
  store i32 %argc, ptr %argc.addr.i, align 4
  invoke void @llvm.seh.try.begin()
          to label %invoke.cont.i unwind label %catch.dispatch5.i

invoke.cont.i:                                    ; preds = %entry
  invoke void @llvm.seh.try.begin()
          to label %invoke.cont2.i unwind label %catch.dispatch.i

catch.dispatch.i:                                 ; preds = %invoke.cont.i
  %0 = catchswitch within none [label %__except.i] unwind label %catch.dispatch5.i

__except.i:                                       ; preds = %catch.dispatch.i
  %1 = catchpad within %0 [ptr null]
  catchret from %1 to label %__except3.i

__except3.i:                                      ; preds = %__except.i
  %2 = tail call i32 @llvm.eh.exceptioncode(token %1)
  store volatile i32 %2, ptr %__exception_code1.i, align 4
  invoke void @llvm.seh.try.end()
          to label %__try.cont8.i unwind label %catch.dispatch5.i

catch.dispatch5.i:                                ; preds = %if.end.i, %__except3.i, %catch.dispatch.i, %entry
  %3 = catchswitch within none [label %__except6.i] unwind to caller

__except6.i:                                      ; preds = %catch.dispatch5.i
  %4 = catchpad within %3 [ptr null]
  catchret from %4 to label %__except7.i

__except7.i:                                      ; preds = %__except6.i
  %5 = tail call i32 @llvm.eh.exceptioncode(token %4)
  br label %__try.cont8.i

__try.cont8.i:                                    ; preds = %__except7.i, %__except3.i
  tail call void @Exit() #0
  unreachable

invoke.cont2.i:                                   ; preds = %invoke.cont.i
  %argc.addr.i.0.argc.addr.i.0.argc.addr.i.0.argc.addr.0.argc.addr.0.argc.addr.0..i = load volatile i32, ptr %argc.addr.i, align 4
  %tobool.not.i = icmp eq i32 %argc.addr.i.0.argc.addr.i.0.argc.addr.i.0.argc.addr.0.argc.addr.0.argc.addr.0..i, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %invoke.cont2.i
  %6 = load volatile ptr, ptr @p, align 8
  store atomic volatile i32 1, ptr %6 release, align 4
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %invoke.cont2.i
  %argc.addr.i.0.argc.addr.i.0.argc.addr.i.0.argc.addr.0.argc.addr.0.argc.addr.0.10.i = load volatile i32, ptr %argc.addr.i, align 4
  store volatile i32 1, ptr %cleanup.dest.slot.i, align 4
  invoke void @llvm.seh.try.end()
          to label %"?ExitOnThrow@@YAHH@Z.exit" unwind label %catch.dispatch5.i

"?ExitOnThrow@@YAHH@Z.exit":                      ; preds = %if.end.i
  %add.i = add nsw i32 %argc.addr.i.0.argc.addr.i.0.argc.addr.i.0.argc.addr.0.argc.addr.0.argc.addr.0.10.i, 5
  call void @llvm.lifetime.end.p0(ptr nonnull %argc.addr.i)
  call void @llvm.lifetime.end.p0(ptr nonnull %__exception_code1.i)
  call void @llvm.lifetime.end.p0(ptr nonnull %cleanup.dest.slot.i)
  %call1 = tail call noundef i32 @"?AlwaysThrows@@YAHH@Z"(i32 noundef %add.i)
  %add = add nsw i32 %call1, %add.i
  ret i32 %add
}

declare void @Exit()
declare i32 @"?AlwaysThrows@@YAHH@Z"(i32 noundef %id)
declare dso_local void @llvm.seh.try.begin()
declare dso_local i32 @__C_specific_handler(...)
declare i32 @llvm.eh.exceptioncode(token)
declare dso_local void @llvm.seh.try.end()
declare void @llvm.lifetime.start.p0(ptr captures(none))
declare void @llvm.lifetime.end.p0(ptr captures(none))

attributes #0 = { noreturn nounwind }

!llvm.module.flags = !{!0}
!0 = !{i32 2, !"eh-asynch", i32 1}
